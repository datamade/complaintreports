\documentclass{article}
\usepackage{amsmath}
\usepackage{url}
\usepackage{enumitem}
\usepackage{lipsum}

\begin{document}


<<include=FALSE>>=
library(knitr)
opts_chunk$set(
echo=F, fig.width=4.5, fig.height=4.75, fig.path='/home/fgregg/sweave-cache/figs/fig', cache=T, results='hide'
)
knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark=",")
})
@

With the current data, we can show some facts about police misconduct
and it's investigation. If we take complaints as an imperfect
indicator of police misconduct, we can observe that:

\begin{enumerate}[noitemsep]
\item Officers who draw many complaints are unusual in the force and
  within their unit
\item Officers with many complaints are connected to one another
\end{enumerate}

\noindent By looking at how complaints get processed, we can see that in the 
investigation process:

\begin{enumerate}[noitemsep]
\item Few complaints are sustained 
\item The penalties for sustained complaints are meager
\item If police officers are the investigators, complainants are much
  less willing to sign affidavits than if investigated by IPRA staff.
\end{enumerate}

I'll first discuss the patterns we can establish with current data,
and then will be possible with additional data.

\section*{Currently Demonstrable Patterns}
\subsection*{Police Misconduct}
\subsubsection*{Multiple Complaints Are Rare}
<<allcomplaints>>=
library(RPostgreSQL)
con <- dbConnect(RPostgreSQL::PostgreSQL(), dbname="complaints")

verbal_abuse <- c('01B')
excessive_force <- c('05A', '05B', '05C', '05D', '05F',
                     '05G', '05H', '05J', '05K', '05L',
                     '05M', '05N', '05P', '05Q')
ipra_complaints <- c(verbal_abuse, excessive_force)

first_amendment <- c('03A', '03B', '03C', '03D', '03E', '03F', '03G')
search <- c('04A', '04B', '04C', '04D', '04E', '04F', '04G', '04H', '04J')

external_complaints_non_ipra <- c(first_amendment, search)

external_complaints <- c(external_complaints_non_ipra, ipra_complaints)

all_po <- dbGetQuery(con,
                     paste(
    "SELECT count(distinct complaint_id) AS count \
     FROM (SELECT * FROM accused WHERE complaint IN ('",
     paste(external_complaints, collapse="', '"),
     "')) AS external_complaints \                         
     INNER JOIN officers \
     USING (officer_id) \
     WHERE current_rank = 'PO' \
     GROUP BY officer_id \
     ORDER BY count(*)"))[,1]
@ 

Between September 2011 to May 2015, \Sexpr{length(all_po)} police
officers had at least one complaint that included an allegation of
verbal abuse with bias, excessive force, first amendment violations or
illegal searches.\footnote{We are assuming that no officers changed
  rank during this period. There are certainly some detectives,
  sergeants, and other higher officers in 2015 that were police
  officers at some point between between September 2011 and May
  2015. We are not counting these} During this period, the police
department had around \Sexpr{9300} police officers on payroll.

Of the officers with a complaint, \Sexpr{sum(all_po == 1)} police
officers had only one and 90\% of officers had four our fewer
complaints.  Only \Sexpr{sum(all_po >= 15)} officers had fifteen or
more complaints. That's about 1 in 1000. (Figure~\ref{po-complaint-fig})

\begin{figure}
<<>>=
barplot(table(all_po), 
        main='Complaints against Police Officers',
        xlab='Number of complaints',
        ylab='Police Officers')
@ 
\label{po-complaint-fig}
\caption{Complaints against Police Officers from 2011 to 2015}
\end{figure}


Multiple complaints are not just rare overall, they are rare in every
police unit. While average number of complaints does vary
substantially, in every unit there are a few officers who gather many
more complaints than the rest of their units. We can see this pattern
by looking at the six units with the highest average number of
complaints per officer in Figure~\ref{complaints-unit-fig}.

\begin{figure}
<<byunits>>=
units <- dbGetQuery(con, 
    paste(
    "SELECT current_unit, AVG(count), COUNT(*) as avg_count FROM
     (SELECT current_unit, count(distinct complaint_id) AS count \
      FROM accused INNER JOIN officers \
      USING (officer_id) \
      WHERE complaint IN ('",
      paste(external_complaints, collapse="', '"),
      "') \
        AND current_rank = 'PO' \
      GROUP BY officer_id, current_unit) AS officer_count \
     GROUP BY current_unit \
     HAVING COUNT(*) > 10
     ORDER BY AVG(count) DESC"))

officer_units <- dbGetQuery(con, 
    paste(
    "SELECT current_unit, count(distinct complaint_id) AS count \
     FROM accused INNER JOIN officers \
     USING (officer_id) \
     WHERE complaint IN ('",
     paste(external_complaints, collapse="', '"),
     "') \
     GROUP BY officer_id, current_unit"))

par(mfrow=c(3,2))

unit_names = c('212'='Bureau of Patrol - South',
               '189'='Narcotics Division',
               '192'='Vice and Asset Forfeiture',
               '311'='Gang Enforcement - Central',
               '393'='Gang Enforcement Division',
               '312'='Gang Enforcement - South',
               '213'='Burea of Patrol - North')

for (i in 1:6) {
    unit = units[i, 'current_unit']
    avg = units[i, 'avg']
    n = units[i, 'n']
    barplot(table(officer_units[officer_units$current_unit == unit, 'count']),
         main = paste(unit_names[as.character(unit)],
                      '\nAverage: ',
                      signif(avg,2),
                      sep=''),
         xlab="Number of complaints",
         ylab="Police Officers")
}    
par(mfrow=c(1,1))
@ 
\label{complaints-unit-fig}
\caption{Complaints by unit}
\end{figure}

Officers who receive multiple complaints are not just having an
unlucky year. If many complaints are made against an officer in one
year, then its likely that many complaints will be against that
officer in the next year (Figure~\ref{complaints-year-fig}).

\begin{figure}
<<complaintsbyyear>>=
yearly_complaints <- dbGetQuery(con,
                                paste(
    "SELECT year, officer_id, count(complaint_id) AS complaints, \
            max(current_unit) as unit, max(current_rank) as rank, \
            max(gender) as gender, max(race) as race
     FROM \
     (SELECT EXTRACT(YEAR FROM incident_date::TIMESTAMP) AS year, \
             officer_id, \
             complaint_id \
      FROM accused INNER JOIN complaints \
      USING (complaint_id) \
      WHERE complaint IN ('",
     paste(external_complaints, collapse="', '"),
     "') \                               
      ) AS complaints \
     RIGHT OUTER JOIN \
     (SELECT * \ 
      FROM officers CROSS JOIN \
      (SELECT UNNEST(ARRAY[2012,2013,2014]) AS year) AS years \
      WHERE current_rank='PO' \
      ) AS officer_years \
     USING (year, officer_id) \
     GROUP BY officer_id, year"))
yearly_complaints <- na.omit(yearly_complaints)

yearly_complaints <- data.frame('2012'=yearly_complaints[yearly_complaints$year == '2012', 
                                  'complaints'], 
                                '2013'=yearly_complaints[yearly_complaints$year=='2013', 
                                           'complaints'],
                                '2014'=yearly_complaints[yearly_complaints$year=='2014', 
                                    'complaints'])

yearly_complaints <- yearly_complaints[rowSums(yearly_complaints) > 0,]

over_time <- data.frame(previous_year = c(yearly_complaints$X2012,
                                          yearly_complaints$X2013),
                        next_year = c(yearly_complaints$X2013,
                                      yearly_complaints$X2014))

x.bin <- 0:max(over_time$previous_year)
y.bin <- 0:max(over_time$next_year)

freq <-  as.data.frame(table(findInterval(over_time$previous_year, x.bin),
                             findInterval(over_time$next_year, y.bin)))

freq[,1] <- as.numeric(freq[,1])
freq[,2] <- as.numeric(freq[,2])

freq2D <- mat.or.vec(length(x.bin), length(y.bin))
freq2D[cbind(freq[,1], freq[,2])] <- freq[,3]

# Normal
image(x.bin, y.bin, freq2D^(1/3), col=grey.colors(200, start=1, end=0),
      main="Complaints Across Years", xlab="Complaints in Previous Year", ylab="Complaints in Next Year")
@ 
\caption{Complaints By Year}
\label{complaints-year-fig}
\end{figure}

\paragraph{Recommended visualization: Sorted Heatmap} I recommend you
show two heatmaps of the number of complaints by officer by year. The
first should be very narrow and long to demonstrate that the vast bulk
of officers have very few complaints, while a few have many and many
every year. The second heatmap should be a zoomed in view, that shows
the details for officers. On the web, these two visualizations should
be coupled so that detail view is aligned to slider of the macro view (Figure \ref{recommended-viz-fig}).

\begin{figure}
  \begin{minipage}{0.40\textwidth}
<<fig.width=1.3, fig.height=5>>=
image(as.matrix(t(tail(yearly_complaints[order(rowSums(yearly_complaints)),], 500))), 
       col=grey.colors(200, start=1, end=0),
       axes=FALSE)
@ 
  \end{minipage}\hfill
  \begin{minipage}{0.40\textwidth}
<<fig.width=1.8, fig.height=5>>=
image(as.matrix(t(tail(yearly_complaints[order(rowSums(yearly_complaints)),], 20))), 
       col=grey.colors(200, start=1, end=0),
       axes=FALSE)
axis(2, at = 0:19/19, labels=paste('Officer', 20:1), tick=FALSE, las=1, cex.axis=0.7)
axis(3, at = c(0, 0.5, 1), labels=c('2012', '2014', '2015'), tick=FALSE, las=2)
@ 
\end{minipage}
\label{recommended-viz-fig}
\caption{Complaints By Year, Top 20 and All}
\end{figure}


<<>>=
library(igraph)

focal <- c(5513, 3658, 3963, 7181)

relations <- data.frame(from=character(), to=character(), count=integer())

for (ego in focal) {
    relations <- rbind(relations,
                       dbGetQuery(con, 
                                  paste("SELECT", ego, 
                                        "AS from, officer_id AS to, \
                                         COUNT(distinct complaint_id) as count \
                                         FROM accused \
                                         WHERE complaint_id \
                                           IN (SELECT complaint_id \
                                               FROM accused \
                                               WHERE officer_id = ", ego, ") \
                                           AND officer_id != ", ego, " \
                                           GROUP BY officer_id")))
}

g <- graph.data.frame(relations, directed=FALSE)
g <- simplify(g, remove.multiple = TRUE)

num_complaints <- dbGetQuery(con,
                             paste(
                             "SELECT officer_id, count(distinct complaint_id) \
                              FROM accused WHERE officer_id IN (",
                                 paste(unique(relations$to), collapse=", "),
                                 ") GROUP BY officer_id"))

num_complaints <- setNames(num_complaints[,2], 
                           as.character(num_complaints[,1]))

g <- delete.vertices(g, 
                     which(attr(V(g), 'names') 
                           %in% 
                           names(num_complaints)[num_complaints <= 10]))



num_complaints <- num_complaints[attr(V(g), 'names')]
            
                          

    
plot(g,layout=layout.fruchterman.reingold(g,weights=E(g)), vertex.size=num_complaints)


@ 

\subsection*{Few complaints are sustained}
Current police complaint procedures result in only X percent of complaints
being sustained. Y percent are dismissed because the complainant is
not willing to sign an affidavit. In Z percent of the cases, the
investigators are unable to find sufficient evidence. 
    
<<load, include=FALSE, eval=FALSE>>=
library(lme4)
library(xtable)




model <- lme4::glmer(complaints ~ (I(year-2013) + 
                                   + (1 + I(year-2013) | rank)
                                   + (1 + I(year-2013) | unit)
                                   + (1 + I(year-2013) | officer_id)
                                   ), 
                     data = yearly_complaints,
                     family = "poisson")

police_units <- ranef(model)$unit
top_police_units <- row.names(police_units)[order(-police_units[,1])][1:10]


top_officers_complaints <- dbGetQuery(con,
                           paste("SELECT * FROM accused ",
                                 "WHERE officer_id IN (",
                                 paste(top_officer_ids, collapse=','),
                                 ") order by officer_id, complaint_id",
                                 sep=''))


                              

@ 

\section*{Cost of Impunity}
The lack of police accountability costs our city in harm and
death to our residents, high costs in settlements, and loss of trust
between police and communities.

This argument has a number of components

\begin{enumerate}
  \item The IPRA is not catching true cases of police misconduct.
  \item When the IPRA does sustain misconduct, the consequences are meager
  \item The Police could catch troubling patterns early
  \item Harm and treasure could have been avoided if patterns caught early
\end{enumerate}

\subsection*{IPRA Fails to Detect True Cases of Police Misconduct}

From the CR data, we can see that a tiny fraction of complaints are
sustained. For the skeptic, it is not clear how to interpret this. It
could be, as the FOP claims, that nearly all complaints are baseless
and retaliatory. Without a separate way of judging the validity of
these complaints, we can't know what the rate of sustaining complains
should be.

The most convincing sign that a complaint was valid are criminal convictions
of police officers. If IPRA is only sustaining a fraction of
complaints for violations that a jury later finds to be a criminal
offense, that's very strong evidence that IPRA is capable of
effectively investigating and judging police complaints.

Civil cases can serve as similar evidence. However, since they are
almost always settled, discrepancies between settlement rates and IPRA's
sustaining rates are more equivocal. It could be that IPRA is
sustaining too few cases or that the city is settling too many
cases. 

\subsection*{Consequences for Misconduct are Meaningless}
Even when the IPRA sustains a complaint of police misconduct, the
consequences are meaningless.

I can't think of a better illustration of that than the two cases
where the IPRA sustained complaints of rape/sexual violence and did
not fire the officers.

We can also go back to the criminal conviction and settlement data,
and show the IPRA consequences for officers involved in settlements.

\subsection*{The CPD Could Detect Troubling Officer Early}
They city claims that complaint reports cannot distinguish between
criminal police officers and aggressive, but professional
officers. This is theory that can be tested in to ways.

Retrospectively, once the Invisible Institute secures more historic
complaint data, we show that officers convicted of crimes have a
markedly different pattern of complaint reports than other officers.

Prospectively, with the data that we have right now, we can find
officers who are outliers in the complaints made against them. If we
investigate these officers and find that these officers are indeed
engaged in improper behavior, we would have demonstrated that
complaint data \emph{can} be used to find criminal cops.

Here are the ten officers who are the largest outliers in the past
four years, controlling for the unit and rank of the
officer.\footnote{The model is mixed effects Poisson regression model:
  
\begin{align*}
&\log{\operatorname{E}(y_{ijkt})} = \pi_{0ijk} + \pi_{1ijk} \cdot \text{Year}_t \\
&\pi_{0ijk} = \beta_{0000} + \beta_{0i00} + \beta_{00j0} +
  \beta_{000k} \\
&\pi_{1ijk} = \beta_{1000} + \beta_{1i00} + \beta_{10j0} +
  \beta_{100k} \\
&\beta_{0i00} = b_{0i} \\
&\beta_{00j0} = c_{0j} \\
&\beta_{000k} = d_{0k} \\
&\beta_{1i00} = b_{1i} \\
&\beta_{10j0} = c_{1j} \\
&\beta_{100k} = d_{1k}
\end{align*}

Where $y_{ijkt}$ is the number of complaints made against officer $i$,
in unit $j$ with rank $k$ in year $t$.

$u_{0i}$ is the officer specific random effect of the officer on the
average number of complaints per year. This is what we are ranking the
officer by. This model controls for the unit and the rank of the officer.
}

<<top_officers, results='asis'>>=

officers <- ranef(model)$officer_id

top_officer_ids <- row.names(officers)[order(-officers[,1])][1:10]

top_officers <- dbGetQuery(con,
                           paste("SELECT * FROM officers ",
                                 "WHERE officer_id IN (",
                                 paste(top_officer_ids, collapse=','),
                                 ")",
                                 sep=''))

top_officers$date_of_appointment <- as.character(top_officers$date_of_appointment)
tab <- xtable::xtable(top_officers[,c(1:4, 6:7)])
names(tab) <- c("Officer", "Star", "Date of Appointment", "Race", "Rank", "Unit")

print(tab, row.names=FALSE, include.rownames=FALSE)
@ 


\section*{Data and Miscellaneous Notes}
In the file
\url{CPD_Allegations_Complete_Database_-_May_28_2015.xlsx}, there is
no easy way to know whether data came from the Moore, Bond, or
Invisible Institute data releases. A \texttt{Source} column should be
added.

The Moore dataset is supposed to have record from 2002-2008, but there
do not appear to be any records from 2007 or 2008. The records with
record ids between 19445 and 26786 appear to be the Moore records but have
dates between 2011 and 2015.

Data is censored. Does not show cops to had no complaints. What can we
do about that? Relatedly, can we get data on the assignment and ranks
of officers at the time of the complaint report incidents?

FOP's argument is that affidavit's filter out baseless claims. If that
was true, then sustained rate should have gone up after the affidavit
requirement. Did that happen?





\end{document}

Only a small fraction of the IAD investigations show up in accused file.

 Why are so many investigation not have an allegation code?

09A would seem to be a domestic violence report but only 4\% of them are investigated by IPRA, even though it says that all will be investigated by IPRA

John Stahl, a police sargeant, seemed to have investigated a case where there was an allegation of verbal abuse with bias, complaint id: 1063852 This is the only case where this type of allegation was not investigated by an IPRA investigator.

Philip Paluch, a police sargeant, investigated an excessive force complaint 1048571. Elizabeth Ramirez investigated an excessive force complaint 1045498 

Mark Higgs investigated an excessive force complaint 1052098

When do commanding officers versus IPRA staff investigate verbal abuse that is not 1B?

Some b

hernandez neomi
pamela cureton
william walsh


\begin{enumerate}
  \item IPRA is failing to sustain true complaints
  \item The department could identify criminal police officers by
    looking at their complaint history
\end{enumerate}

<<sankey, eval=FALSE>>=


resolved_complaints <- dbGetQuery(con,
    paste("select count(*), recommended_finding from accused, complaints where accused.complaint_id = complaints.complaint_id and investigator in (select name from ipra_employees) and recommended_finding != '' and complaint in ('",
          paste(ipra_complaints, collapse="', '"),
          "') group by recommended_finding order by count(*) desc", sep=''))  

counts <- resolved_complaints$count
if (length(counts) < 5) {
    counts <- c(counts, 0)
}

SankeyR(sum(counts), 
        counts,
        labels=c("Complaints", "No affidavit", "Not sustained", "Unfounded", "Exonerated", "Sustained"), 
        unit="")

all_complaints <- dbGetQuery(con, 'select recommended_finding, complaint from accused')

complaints_by_ipra <- dbGetQuery(con, "select complaint, ipra from accused inner join (select complaint_id, investigator, case when investigator = 'KLIMAS, ROBERT' then 'IAD' when name is null then 'CPD' when name is not null then 'IPRA' end as ipra from complaints left join ipra_employees on complaints.investigator = ipra_employees.name) as investigators using (complaint_id)")


@ 

Todo: scrape http://www.chicagopolice.org/2013MayDirectives/data/a7a57be2-129add9f-15f12-9add-9fea37e07625ed82.html?ownapi=1
